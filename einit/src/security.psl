/* Security configuration of the "traffic light" example. */
/* nk.basic._ is required for comparison operations support in policies, like != below */
use nk.basic._
use nk.hashmap._

/* Definition of the execute interface. */
execute: kl.core.Execute

/* Import the file with the declaration of basic security policy aliases. */
use nk.base._

/* Declaration of entities. */
use EDL Einit
use EDL kl.core.Core

use EDL kl.VfsNet
use EDL kl.drivers.BSP
use EDL kl.drivers.GPIO
use EDL client.Client

use EDL traffic_light.ControlSystem
use EDL traffic_light.LightsGPIO
use EDL traffic_light.Diagnostics

use EDL traffic_light.KlogEntity
use EDL traffic_light.KlogStorageEntity

request src=traffic_light.KlogEntity dst=traffic_light.KlogStorageEntity interface=kl.KlogStorage method=write { grant () }
response src=traffic_light.KlogStorageEntity dst=traffic_light.KlogEntity interface=kl.KlogStorage method=write { grant () }

request src=traffic_light.KlogEntity, dst=kl.core.Core {
    // Interface to the Synchronization service.
    match interface=kl.core.Sync { grant () }
    // Interface to the Task service.
    match interface=kl.core.Task {
        match method=FreeSelfEnv { grant () }
        match method=GetPath { grant () }
        match method=GetName { grant () }
        match method=Exit { grant () }
    }
    // Interface to the Virtual Memory Manager (VMM) service.
    match interface=kl.core.VMM { grant () }
    // Interface to the Thread service.
    match interface=kl.core.Thread { grant () }
    // Interface to the Hal service.
    match interface=kl.core.HAL, method=DebugWrite { grant () }
    match interface=kl.core.HAL, method=GetEnv { grant () }
    // Interface to the HandleManager service.
    match interface=kl.core.Handle { grant () }
    // Audit interface of the Vlog component.
    match interface=kl.core.Audit { grant () }
}

response src=kl.core.Core, dst=traffic_light.KlogEntity { grant () }

request src=traffic_light.KlogStorageEntity, dst=kl.core.Core {
    // Interface to the Synchronization service.
    match interface=kl.core.Sync { grant () }
    // Interface to the Task service.
    match interface=kl.core.Task {
        match method=FreeSelfEnv { grant () }
        match method=GetPath { grant () }
        match method=GetName { grant () }
        match method=Exit { grant () }
    }
    // Interface to the Virtual Memory Manager (VMM) service.
    match interface=kl.core.VMM { grant () }
    // Interface to the Thread service.
    match interface=kl.core.Thread { grant () }
    // Interface to the Hal service.
    match interface=kl.core.HAL, method=DebugWrite { grant () }
    match interface=kl.core.HAL, method=GetEnv { grant () }
    // Interface to the HandleManager service.
    match interface=kl.core.Handle { grant () }
}

response src=kl.core.Core, dst=traffic_light.KlogStorageEntity { grant () }

policy object audit_specification : Base {}

request src=traffic_light.LightsGPIO,
    dst=traffic_light.Diagnostics,
    endpoint=diagnostics.dmessage,
    method=DMessage {
        audit_specification.grant()
}

response src=traffic_light.Diagnostics,
    endpoint=diagnostics.dmessage,
    dst=traffic_light.LightsGPIO
    method=DMessage {
        audit_specification.grant()
}

// We declare the profile for audit.
audit profile trace = {
    // Complete silence.
    0: {},
    // Only denied by kss.
    1: {
        base: { kss: [ "denied" ] },
    },
    // Only denied from everyone.
    2: {
        base: { kss: [ "denied" ] },
        audit_specification: { kss: [ "denied" ] }
    },
    // All listening.
    3: {
        base: { kss: [ "granted", "denied" ] },
        audit_specification: { kss: [ "granted", "denied" ] },
    },
    // audit_trace messages only
    4: {
        base: { kss: [] },
        audit_specification: { kss: [ "granted", "denied" ] },
    },
}
// We assign the level of the audit profile used by default.
audit default = trace 4



/***/

/* Security policy. */
policy object tl_cycle_specification : HashSet {
    type Entry = [UInt32, UInt32]

    config = {
        set_size: 18,
        pool_size: 1
    }
}


/* Execution of entities allowed. */
execute {
    grant ()
}

/* Initialization  security policy and filling traffic light cycle rules. */
execute src=Einit dst=traffic_light.LightsGPIO{

    tl_cycle_specification.init {sid : dst_sid}

    tl_cycle_specification.add {sid : dst_sid, entry : [0x04, 0x01]} // WorkGreen | WorkRed
    tl_cycle_specification.add {sid : dst_sid, entry : [0xC, 0x01]}  // WorkGreenBlink | WorkRed
    tl_cycle_specification.add {sid : dst_sid, entry : [0x02, 0x01]} // WorkYellow | WorkRed
    tl_cycle_specification.add {sid : dst_sid, entry : [0x01, 0x01]} // WorkRed | WorkRed
    tl_cycle_specification.add {sid : dst_sid, entry : [0x01, 0x03]} // WorkRed | WorkRed+WorkYellow

    tl_cycle_specification.add {sid : dst_sid, entry : [0x01, 0x04]} // WorkRed | WorkGreen
    tl_cycle_specification.add {sid : dst_sid, entry : [0x01, 0xC]}  // WorkRed | WorkGreenBlink
    tl_cycle_specification.add {sid : dst_sid, entry : [0x01, 0x02]} // WorkRed | WorkYellow
    tl_cycle_specification.add {sid : dst_sid, entry : [0x03, 0x01]} // WorkRed+WorkYellow | WorkRed

    //special mode
    tl_cycle_specification.add {sid : dst_sid, entry : [0xA, 0xA]} // WorkYellowBlink | WorkYellowBlink
    tl_cycle_specification.add {sid : dst_sid, entry : [0x0, 0x0]} // WorkOff | WorkOff

    grant ()
}

/* allow diagnostic module. */
request src=traffic_light.Diagnostics dst=kl.core.Core {
    grant ()
}

/* Request messages allowed. */
request src=traffic_light.ControlSystem {
    grant ()
}


request src=traffic_light.ControlSystem dst=kl.core.Core {
    grant ()
}


request src=traffic_light.ControlSystem
    dst=traffic_light.LightsGPIO
    endpoint=lightsGpio.mode
    method=FMode {
        grant()
}

/* There is setting light mode*/
request src=traffic_light.ControlSystem
    dst=traffic_light.LightsGPIO
    endpoint=lightsGpio.mode
    method=FMode {
      assert(
        tl_cycle_specification.contains {sid: dst_sid, entry: [message.mode.dir0, message.mode.dir1]} ||
        tl_cycle_specification.contains {sid: dst_sid, entry: [message.mode.dir1, message.mode.dir0]}
      )
}


request src=Einit {
    grant ()
}

request src=kl.core.Core {
    grant ()
}

request src=traffic_light.LightsGPIO dst=kl.core.Core {
    grant ()
}

/* allow request to diagnostics module */
request src=traffic_light.LightsGPIO
    dst=traffic_light.Diagnostics
    endpoint=diagnostics.dmessage
    method=DMessage{
    grant()
}

/* Response messages allowed. */
response {
    grant ()
}

/*
response src=traffic_light.LightsGPIO 
    dst=traffic_light.ControlSystem 
    endpoint=lightsGpio.mode 
    method=FMode {
        assert (message.result < 0x1000404)
}
*/

error {
    grant ()
}

/* Calls to the security interface are ignored. */
security {
    grant ()
}

/**
 * Allows the tasks with the Einit class to start the tasks with the kl.VfsNet class.
 */
execute src=Einit, dst=kl.VfsNet{
    grant()
}

/**
 * Allows the tasks with the kl.VfsNet class to send requests to the KasperskyOS kernel and get
 * responses. This enables the VfsNet program to use core endpoints.
 */
request src=kl.VfsNet, dst=kl.core.Core{
    grant()
}

response src=kl.core.Core, dst=kl.VfsNet{
    grant()
}

/**
 * Allows the tasks with the Einit class to start the tasks with the client.Client class.
 */
execute src=Einit, dst=client.Client{
    grant()
}

request src=client.Client, dst=kl.core.Core{
    grant()
}

response src=kl.core.Core, dst=client.Client{
    grant()
}

request src=client.Client, dst=kl.VfsNet{
    grant()
}

request src=traffic_light.LightsGPIO, dst=kl.VfsNet{
    grant()
}

response src=kl.VfsNet, dst=traffic_light.LightsGPIO{
    grant()
}

response src=kl.VfsNet, dst=client.Client{
    grant()
}

/**
 * Allows the tasks with the kl.drivers.BSP class to send requests to the
 * KasperskyOS kernel and get responses. This enables the BSP driver to use
 * core endpoints.
 */
request src = kl.drivers.BSP, dst = kl.core.Core{
    grant()
}

response src = kl.core.Core, dst = kl.drivers.BSP{
    grant()
}

execute src=Einit, dst=kl.drivers.GPIO{
    grant()
}

/**
 * Allows the tasks with the kl.drivers.GPIO class
 * to send requests to the KasperskyOS kernel and get responses.
 * This enables the GPIO program to use core endpoints.
 */
request src = kl.drivers.GPIO, dst = kl.core.Core{
    grant()
}

response src = kl.core.Core, dst = kl.drivers.GPIO{
    grant()
}